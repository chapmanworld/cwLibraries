(*
  AUTHOR: Craig Chapman for ChapmanWorld LLC. <br/>
  PROPERTY OF: ChapmanWorld LLC. <br/>
  ALL RIGHTS RESERVED. <br/>
*)
unit utlCompile;

interface
uses
  utlStatus
, utlLog
, utlIO
, utlCollections
;

{$region ' Usage information '}
(*

  A compiler consists of many different components which are called upon
  to process source code through to the final output. That output may be
  source code for some other compiler (transpiler), or may be a binary
  executable file (compiler), or may take another form.

  What follows is a high level overview of the function of each component.

    1) Lexing - A lexer simply reads the source code, character by character
                if necessary, to translate it into a list of tokens that
                represent fragments of the source code. The utlCompile library
                provides a common lexer class which is customized by injecting
                a custom implementation of ITokenizer<>. You will be expected to
                provide the implementation of ITokenizer<>.

    2) Parser - The parser translates the tokens that are generated by the
                lexer, into a high-level model. In a typical compiler, this
                high level model is named the "AST" (Abstract Syntax Tree).
                Each AST will be different, as they represent the syntax level
                structures of the language being compiled, but in a more
                machine readable form than the source code.

    3) Transitions - At least one transition must be used to transition the
                     high-level model, which was generated by the parser, to
                     a low-level model. There may be any number of models and a
                     chain of transitions to migrate between them, however, it
                     is typical to have only a high-level and low-level in a
                     compiler. Transitions may optionally be added to the
                     chain which transition to one instance of a model to
                     another instance of the same model. This is typically
                     done by a validation or optimization transition.

    4) CodeGenerator - A code generator takes the low-level model that results
                       from calling the transition(s), and uses it to write
                       an intermediate file (such as a .obj object file) or
                       an assembler file. Ready to be assembled, linked or
                       otherwise used to generate the final output. It is
                       important to understand that the code generator is
                       usually not responsible for generating the final output
                       directly, but that this is typically (though not
                       necessarily) done in a post process.

    5) PostProcess - One or more post processes may be used in series to take
                     the output of the code generator, and use it to generate
                     the final result. This could involve passing an assembler
                     file (generated by the code generator) through an
                     external assembler and linker, though needs will vary
                     between compiler projects.

  In order to create a compiler for a given input syntax, and a given target,
  an instance of ICompileChain is created and configured with the above
  components according to the needs of the compiler. This unit maintains a
  list of compile chains for the current project, and so a compiler can be
  created with multiple input syntax and multiple targets as required.

*)
{$endregion}

{$region ' Status messages '}

const
  stExpected                 : TGUID = '{A0EC058F-A647-4F2E-B391-DFF79DC9D03D}';

const
  ///  <summary>
  ///    stDone is returned by a compile chain as a success code which indicates
  ///    that the compilation process, as defined within the chain setup, is
  ///    complete.
  ///  </summary>
  stDone                     : TGUID = '{D334EEA9-6929-4FD0-9C2E-E475AC51CAD8}';
  stSourceNotParsed          : TGUID = '{BC331C3F-9A51-46BE-A059-9709D34AD257}';
  stModelNotTransitioned     : TGUID = '{9B6069CC-937D-464D-B296-3C450E8B06A6}';
  stNotGenerated             : TGUID = '{D3D84C48-22FF-4614-A485-F191F7728157}';
  stChainAlreadyRegistered   : TGUID = '{AEBEBC3F-279C-479D-963A-A4343E0D2AC8}';


const // Some status messages that may be useful in transitions / generators.
  stVerbose                  : TGUID = '{BF97014F-169F-4685-A246-683A1A178787}';
  stSourceModelIsInvalid     : TGUID = '{C2E179A1-B0D6-4B21-88BC-54C8BD764FFE}';
  stSourceModelIsMissingRoot : TGUID = '{282E3CF1-6197-4BE2-9FCC-2F9BB428DA57}';
  stInvalidTarget            : TGUID = '{10E9A27F-859B-4633-AFFA-3957B93C6F2E}';
  stInvalidPlatform          : TGUID = '{633DB6B3-C965-4ADC-A8AC-A9B9C2572406}';

const
  stModelAlreadyRegistered              : TGUID = '{61B01C84-27AD-48B1-95CD-1B20E2624775}';
  stArchetypeNotFound                   : TGUID = '{62F89E1B-B7D7-4A1D-A9ED-1E3BD2CABB63}';
  stArchetypeAlreadyRegistered          : TGUID = '{0CACBA6C-5D15-4154-BE1F-B020830213CE}';
  stArchetypeFactoryFailed              : TGUID = '{B17BE2D6-EE56-4791-AECE-AB3078E64BE1}';
  stArchetypeImplementationMissing      : TGUID = '{056DDA0F-FAEF-4460-A898-E8CA867440C6}';
  stArchetypeMemberClash                : TGUID = '{9BAC266A-4C78-4269-A87F-04EFC7E5AC4F}';
  stSerializationError                  : TGUID = '{DA34BE78-0798-46B5-979C-A2207B5C19A2}';
  stUnrecognizedDataTypeInStorage       : TGUID = '{ECF7DC73-B10F-46C7-BEA3-0161F7244093}';
  stArchetypeMemberDisplayNameMissmatch : TGUID = '{805A172B-632B-465A-8B5A-E653B139A776}';
  stArchetypeMemberDataTypeMissmatch    : TGUID = '{0FF9E748-0C6D-4668-BE0A-A84CB333BF5B}';
  stArchetypeMemberOffsetMissmatch      : TGUID = '{E53C8540-A41E-4C34-9491-663C10B8A039}';
  stArchetypeIDMissmatch                : TGUID = '{26B29DE9-5229-480D-B87D-176FDE6E4EEE}';
  stArchetypeMemberCountMissmatch       : TGUID = '{0D93DBA2-0AE9-4999-8FFA-4A40299E110B}';
  stArchetypeCountMissmatch             : TGUID = '{92307D05-62BE-4A73-ABB8-26A3D6D3873D}';
  stSignatureInvalid                    : TGUID = '{D3FABFE6-279E-4483-A752-B828ECF1B468}';
  stArchetypeDisplayNameMissmatch       : TGUID = '{8C68EFE7-C0F4-462A-9119-7224632AFDC9}';
  stStorageInvalidBooleanData           : TGUID = '{8F6E584C-DBF9-42AC-B982-38CA69FB52D5}';
  stInvalidStringIndex                  : TGUID = '{C57853EF-9B22-49F2-B84A-00F4E34394E4}';
  stUnidentifiedReference               : TGUID = '{A0B908F6-4374-4365-B433-C48382BB4FE1}';
  stUnidentifiedListItemReference       : TGUID = '{C0884C97-1661-40DB-B006-CC8C25E7B8EE}';
  stUnidentifiedReferenceMemberType     : TGUID = '{E0FB55B0-7246-4849-B8E1-804A687106BC}';
  stInvalidResolveIndex                 : TGUID = '{40A78124-EBCA-471F-973B-F66EF10AE433}';
  stMalformedResolveTable               : TGUID = '{72D48A88-7564-4DE9-A15F-F07DAF7D7F7C}';
  stIdentAddressUnresoved               : TGUID = '{845E08F9-E98C-4C0E-B34A-23EE6A136EFF}';
  stCursorFoundButNotSupported          : TGUID = '{813FD8F1-BD2B-4C88-BCBA-644AD0A44092}';
  stModelInstanceNotAssigned            : TGUID = '{3CBEAE0A-49E9-4FEE-9EBC-01245D649BFD}';
  stRepesentationInstanceNotAssigned    : TGUID = '{46E43E8D-F4E3-44D2-B434-23B7C11D7466}';
  stRepresentationNotFound              : TGUID = '{8481282C-81B9-4D51-BF99-7D5917A0B325}';

{$endregion}

{$region ' TTarget '}

type
  ///  <summary>
  ///    An enumeration of targets that may be
  ///    supported by a compiler based on utlCompile. <br/>
  ///    More may be added as needed. The registration of
  ///    compile chains will determine which are supported
  ///    by any given compiler. <br/>
  ///    This enum is not a requirement of any of the interfaces
  ///    or classes provided by this library, but is here as a convenient
  ///    place to keep this commonly used type.
  ///  </summary>
  {Z4}
  TTarget = (
      tgt_UnSet
    , tgt_x86
    , tgt_x86_64
    , tgt_arm
    , tgt_Aarch64
    , tgt_RISC_V
    , tgt_SPIRV
  );


{$endregion}

{$region ' TPlatform '}

type
  ///  <summary>
  ///    An enumeration of platforms that may be
  ///    supported by a compiler based on utlCompile. <br/>
  ///    More may be added as needed. The registration of
  ///    compile chains will determine which are supported
  ///    by any given compiler. <br/>
  ///    This enum is not a requirement of any of the interfaces
  ///    or classes provided by this library, but is here as a convenient
  ///    place to keep this commonly used type.
  ///  </summary>
  {Z4}
  TPlatform = (
      pl_Unset
    , pl_Windows
    , pl_Linux
    , pl_BSD
    , pl_Android
    , pl_IOS
  );

{$endregion}

{$region ' ICursor '}

type
  ///  <summary>
  ///    A reference counted cursor object that may be obtained
  ///    from the lexer during parsing.
  ///  <summary>
  ICursor = interface
  ['{1F4CC41A-45B1-4A1F-8A33-A5087028C427}']

    ///  <summary>
    ///    The name of the file being scanned when this cursor was generated.
    ///  </summary>
    function Filename: string;

    ///  <summary>
    ///    Returns the line number being scanned when this cursor was generated.
    ///  </summary>
    function LineNumber: nativeuint;

    ///  <summary>
    ///     Returns the line position being scanned when this cursor was generated.
    ///  </summary>
    function LinePosition: nativeuint;

    ///  <summary>
    ///    Copies the contents of SourceCursor to this one.
    ///  </summary>
    procedure Assign( const SourceCursor: ICursor );

  end;

{$endregion}

{$region ' TCursor '}

type
  TCursor = record
    class function Create( const Filename: string; const LineNumber: nativeuint; const LinePosition: nativeuint ): ICursor; static;
  end;

{$endregion}

{$region ' IScanner '}

type
  ///  <summary>
  ///    The utlCompile library provides a standard implementation of this
  ///    IScanner interface to your custom ITokenizer<> implementation. It
  ///    provides methods for reading a source file from an input stream, as
  ///    well as for nesting source streams (i.e. include files).
  ///  </summary>
  IScanner = interface
  ['{A5733AD5-973B-4F9B-9D81-CE7E6EAF263A}']

    ///  <summary>
    ///    Returns an instance of ICursor to describe
    ///    the location of the scanner within the source file(s).
    ///  </summary>
    function Cursor: ICursor;

    ///  <summary>
    ///    Returns the character at the current cursor position within
    ///    the file being scanned. <br/>
    ///    This method does not advance the cursor.
    ///  </sumamry>
    function Current: char;

    ///  <summary>
    ///    Advances the scanning cursor to the next location. <br/>
    ///    When the end of the source code is reached, Advance will
    ///    simply fail to advance the cursor. <br/>
    ///    It is up to the caller to call EndOfFile() to determine if the
    ///    end of file has been reached. EndOfFile() will only return
    ///    true when the cursor has advanced beyond the final character.
    ///  </summary>
    procedure Advance;

    ///  <summary>
    ///    Returns true if the scanner is positioned to look at a character
    ///    beyond the last character in the source.
    ///  </summary>
    function EndOfStream: boolean;

    ///  <summary>
    ///    Inserts a new scanner into this one as a child at the current
    ///    cursor position. All calls to scanner methods will be forwarded
    ///    to the child until it reaches EOF, at which point, the child
    ///    scanner will be disposed and scanning operations revert to
    ///    its parent scanner. <br/> (Allow for include files).
    ///  </summary>
    procedure InsertChild( const Scanner: IScanner );

  end;

{$endregion}

{$region ' IHasCursor '}

type
  ///  <summary>
  ///    This interface is merely a convenience. <br/>
  ///    Many archetypes will want to track a lexer cursor in order to provide
  ///    filename / line number and line position information for error logging
  ///    or debugging purposes. This interface may be used as a base interface
  ///    for those archetypes, providing a consistent way to address a cursor
  ///    over multiple models. <br/>
  ///    If your archetype supports this interface, the serialize and
  ///    deserialize features of utlModels will automatically account for the
  ///    cursor.
  ///  </summary>
  IHasCursor = interface
    ['{9244C5EA-A28C-41BF-ADB0-85F8E0FCAFDC}']

    ///  <summary>
    ///    Returns an instance of ICursor. <br/>
    ///    Note: When you create a representation from an archetype which
    ///    implements IHasCursor, you are responsible for setting the cursor
    ///    information, which must be done via the ICursor.Assign() method.
    ///  </summary>
    function Cursor: ICursor;
  end;

{$endregion}

{$region ' IStorage '}

type
  ///  <summary>
  ///    Used to store the instance data for a representation node.
  ///  </summary>
  IStorage = interface
    ['{B26411A2-2343-425B-9895-B72D66DEF74C}']

    ///  <summary>
    ///    May be used by a representation to call-back to the instance which
    ///    provides this storage, and create another representation by
    ///    archetype. This enables representations to pre-instance reference
    ///    members if required.
    ///  </summary>
    function CreateRepresentation( const ArchetypeID: TGUID ): IInterface;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a string member.
    ///  </summary>
    procedure AddMember( const [ref] Member: string; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a uint8 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: uint8; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a uint16 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: uint16; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a uint32 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: uint32; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a uint64 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: uint64; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a int8 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: int8; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a int16 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: int16; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a int32 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: int32; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a int64 member.
    ///  </summary>
    procedure AddMember( const [ref] Member: int64; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a TGUID member.
    ///  </summary>
    procedure AddMember( const [ref] Member: TGUID; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a single-precision member.
    ///  </summary>
    procedure AddMember( const [ref] Member: single; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a double-precision member.
    ///  </summary>
    procedure AddMember( const [ref] Member: double; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds a boolean member.
    ///  </summary>
    procedure AddMember( const [ref] Member: boolean; const DisplayName: string ); overload;

    ///  <summary>
    ///    AddMember() is used to register an internal member variable from an archetype,
    ///    with the model storage system, allowing a representation to serialize or
    ///    deserialize that data. <br/>
    ///    This overload adds an interface reference member. <br/>
    ///    This overload supports five types of reference as follows. <br/>
    ///    <br/>
    ///    1) An interface reference to any other representation - it must be a
    ///       representation that is registered with the model, in order that it
    ///       be serialized / deserialized. <br/>
    ///    <br/>
    ///    2) An IList< IInterface >, where IInterface in this case must be
    ///       substituted with the interface of a registered archetype. This
    ///       allows lists of 'child' representations to be serialized / deserialzied. <br/>
    ///    <br/>
    ///    3) An IList< string >, allowing representations to store multiple
    ///       items in array-style storage, so long as they can be represented
    ///       as strings. <br/>
    ///    <br/>
    ///    4) An IUnicodeStream, allowing representations to store arbitrary
    ///    data items. <br/>
    ///    <br/>
    ///    5) An ICursor from utlLexers, for tracking the parsing cursor used
    ///    to generate the model. <br/>
    ///    <br/>
    ///    Using an interface reference to something other than a registered
    ///    archetype, a list of registered archetype, or list of string, will
    ///    result in an exception upon serialization or deserialization. <br/>
    ///    References of any type, which are set to nil, are serialized and
    ///    deserialized regardless. <br/>
    ///    Note that IList< string > is actually handled by another,
    ///    undocumented overload, as the Supports() method in Delphi appears to
    ///    be unable to distinguish between IList< IInterface > and
    ///    IList< string >. This is probably just another case of Delphi's poor
    ///    generics implementation. <br/>
    ///  </summary>
    procedure AddMember( const [ref] Member: IInterface; const DisplayName: string ); overload;
    ///  <exclude/>  - If you found this, see notes on the Member: IInterface overload above.
    procedure AddMember( const [ref] Member: IList< string >; const DisplayName: string ); overload;
    ///  <exclude/>  - If you found this, see notes on the Member: IInterface overload above.
    procedure AddMember( const [Ref] Member: IUnicodeStream; const DisplayName: string ); overload;
    ///  <exclude/>  - If you found this, see notes on the Member: IInterface overload above.
    procedure AddMember( const [Ref] Member: ICursor; const DisplayName: string ); overload;
  end;

{$endregion}

{$region ' Representation Factory '}

type
  ///  <summary>
  ///    In order to instance the nodes of a representation,
  ///    the IRepresentation.Create() method requires that a factory
  ///    method be provided.
  ///  </summary>
  TRepresentationFactory = function( const Storage: IStorage ): IInterface;

{$endregion}

{$region ' IModelInstance '}

type
  ///  <summary>
  ///    Represents an instance of a defined model. <br/>
  ///  </summary>
  IModelInstance = interface
    ['{83A277E2-2A32-4528-876D-BA63AA066A00}']

    ///  <summary>
    ///    Creates an instance of an archetype that is registered with
    ///    the model for this instance. We refer to the instance of an
    ///    archetype as a representatoin. <br/>
    ///    The archetype is looked up using its guid, and the appropriate
    ///    representation factory called. The return value
    ///    from this method may then be cast to an interface for the
    ///    archetype accordingly.  f.x. <br/>
    ///    <br/>
    ///    ConstantDeclaration := MyAST.Instance( IConstantDeclaration ) as IConstantDeclaration; <br/>
    ///    <br/>
    ///    This instance retains a reference to the representation, keeping
    ///    it active so long as the instance is active, and therefore making it
    ///    possible to serialize / deserialize the entire instance. <br/>
    ///  </summary>
    function CreateRepresentation( const ArchetypeID: TGUID ): IInterface;

    ///  <summary>
    ///    Some archetypes are shared across multiple models, and it is often
    ///    necessary during transitioning from one model to another, to pass
    ///    representations of these shared archetypes from the source model to
    ///    the target model. This cannot be done simply by reference, because a
    ///    model instance must maintain an internal list of representations for
    ///    serialization / deserialization purposes. This method allows the
    ///    caller to pass in a representation from another model, only if, the
    ///    current model is able to recognize the archetype.
    ///  </summary>
    function TransferRepresentation( const SourceModelInstance: IModelInstance; const RepresentationInstance: IInterface ): IInterface;

    ///  <summary>
    ///    Disposes a representation created by a call to CreateRepresentation(). <br/>
    ///    Note: If the representation does not exist within the instance, this method
    ///    will do nothing and silently return. <br/>
    ///  </summary>
    procedure RemoveRepresentation( const RepresentationInstance: IInterface );

    ///  <summary>
    ///    Finds the first instance which supports the specified archetype.
    ///  </summary>
    function FindFirst( const ArchetypeID: TGUID ): IInterface;

    ///  <summary>
    ///    Returns the string that was used to register the model from which
    ///    this instance was created. This may be used to confirm that the
    ///    instance contains the correct model.
    ///  </summary>
    function ModelName: string;

    ///  <summary>
    ///    A method which serializes this instance to a stream in binary form. <br/>
    ///    A binary file serialized by a call to serialize() may be
    ///    deserialized with a call to deserialize().
    ///  </summary>
    function Serialize( const TargetStream: IStream ): TStatus;

    ///  <summary>
    ///    A method which deserialzies this instance from a stream which
    ///    was previously serialized using the 'Serialize()' method.
    ///  </summary>
    function Deserialize( const SourceStream: IStream ): TStatus;

    ///  <summary>
    ///    Serializes the model to the target stream in json format for
    ///    debugging purposes. ( utf8encoded without BOM ).
    ///  </summary>
    function SerializeJson( const TargetStream: IUnicodeStream ): TStatus;

  end;

{$endregion}

{$region ' IModel '}

type
  ///  <summary>
  ///    IModel represents the definition of a model for storing arbitrary
  ///    data. It is essentially a container with which you may register
  ///    an interface GUID and a factory method for creating an instance
  ///    to satisty that interface.
  ///  </summary>
  IModel = interface
  ['{39698DC2-FF9F-4B34-992F-DBB2CA9C9E71}']

    ///  <summary>
    ///    An Archetype is a 'type-of-node' within your abstraction model. <br/>
    ///    For instance, in a syntax tree with a node for storing constant
    ///    declarations, there would be a 'constant declaration' archetype. <br/>
    ///    In code, your archetype can be any class which implements an interface.
    ///    You should register that archetype with a call to this method. <br/>
    ///    You should provide a unique identifier for your archetype in the form
    ///    of a GUID. This is typically the guid of an interface which represents
    ///    the archetype. You should also provide a factory method which, when
    ///    called, creates an object instance which implements the interface.
    ///    Finally, you may *should* supply a display name which will be used
    ///    to represent the archetype when serializing to any text format, such
    ///    as XML serialization for instance. <br/>
    ///    An example call to RegisterArchetype might look like this: <br/>
    ///    <br/>
    ///    Model.RegisterArchetype( IConstantDeclaration, TConstantDeclaration.Factory, 'Constant-Declaration' ); <br/>
    ///    <br/>
    ///    If registration of the archetype fails for any reason, such as a non-unique identifier
    ///    for instance, an exception will be raised.
    ///  </summary>
    procedure RegisterArchetype( const ArchetypeID: TGUID; const Factory: TRepresentationFactory; const DisplayName: string );

    ///  <summary>
    ///    Creates an instance of IModelInstance, that-is, an instance of this
    ///    model. The IModelInstance reference may be considered as
    ///    the root node of a model instance, and may be used to futher create
    ///    instances of archetypes registered with the model.
    ///  </summary>
    function CreateInstance: IModelInstance;
  end;

{$endregion}

{$region ' IModels '}

type
  ///  <summary>
  ///    A container for storing and retrieving models. <br/>
  ///  </summary>
  IModels = interface
    ['{31A48D22-2A88-470F-9E73-F55867A522ED}']

     {$region ' Getters / Setters '}
     ///  <exclude/> - Getter for 'Models' property.
     function getModel( const Name: string ): IModel;
     {$endregion}

    ///  <summary>
    ///    Register a new model. <br/>
    ///    Your model must be given a unique name, which may later
    ///    be used to retrieve its instance when required. <br/>
    ///  </summary>
    function RegisterModel( const Name: string ): IModel;

    ///  <summary>
    ///    Provides array-style access to registered models using
    ///    the unique identifier of a model as its index. <br/>
    ///  </summary>
    property Models[ const Name: string ]: IModel read getModel; default;
  end;

{$endregion}

{$region ' ITokenizer< TTokenType > '}

type
  ///  <summary>
  ///    ITokenizer< TTokenType > is the piece of the lexer that you must
  ///    supply. Implement this interface, and instance a lexer from within
  ///    your parser in order to make use of the generated token stream.
  ///  </summary>
  ITokenizer< TTokenType > = interface
    ['{582BF433-F976-4AFF-9129-387982704172}']

    ///  <summary>
    ///    Because ITokenizer<> is a generic type, allowing for any data-type
    ///    to be provided to represent tokens, utlLexer has no way to know
    ///    which value should be returned by a lexer when it reaches the
    ///    end of the input stream. <br/>
    ///    This method should return an approprote value for the end of
    ///    stream token.
    ///  </summary>
    function EOSToken: TTokenType;

    ///  <summary>
    ///    Because ITokenizer<> is a generic type, allowing for any data-type
    ///    to be provided to represent tokens, utlLexer has no way to know
    ///    which value should be returned by a lexer when it is unable to
    ///    determine the next token value. <br/>
    ///    This method should return an approprote value for the end of
    ///    stream token.
    ///  </summary>
    function UnknownToken: TTokenType;

    ///  <summary>
    ///    The Delphi compilers implementation of generics is a little
    ///    under developed. The compiler is not able to perform equality
    ///    tests on two items of the parameterized type, even when the
    ///    parameterized type is the same data-type. <br/>
    ///    Implement AreEqual() to help the compiler out. Maybe someday
    ///    I'll port this all back to the freepascal compiler so that such
    ///    methods aren't needed.
    ///  </summary>
    function AreEqual( const A: TTokenType; const B: TTokenType ): boolean;

    ///  <summary>
    ///    Your tokenizer should read characters from the scanner so long
    ///    as the current character is one which should be considered as
    ///    whitespace for the input syntax. <br/>
    ///    For each whitespace character encountered, call Scanner.Next <br/>
    ///    You must also check Scanner.EndOfStream for every character read
    ///    and simply exit SkipWhitespace of EndOfStream is encountered.
    ///  </summary>
    procedure SkipWhitespace( const Scanner: IScanner );

    ///  <summary>
    ///    Your implementation of GetNexttoken() should read characters from
    ///    the scanner in order to determine the next token value. When the
    ///    value is identified, set the 'Token' var parameter to an appropriate
    ///    token value. <br/>
    ///    If you are unable to determine the next token, exit without altering
    ///    the 'Token' parameter. <br/>
    ///    If it is relevant, your implementation of GetNextToken must also
    ///    set the 'Data' var parameter. For instance, if tokenizing an
    ///    identifier named 'XYZ', you should set the 'Token' parameter to
    ///    a token such as tkIdentifier, and the Data parameter to 'XYZ' in
    ///    order that the lexer is able to present the identifier name to
    ///    a parser.
    ///  </summary>
    procedure GetNextToken( const Scanner: IScanner; var Token: TTokenType; var Data: string );

  end;

{$endregion}

{$region ' ILexer< TTokenType > '}

type
  ///  <summary>
  ///    A lexer is responsible for reading 'tokens' from an input stream
  ///    in order that the parser can make use of them. This is a generic
  ///    implementation of a lexer that can be instanced via the TLexer<>
  ///    factory record below. <br/>
  ///    The actual functionality for this lexer is injected in the form
  ///    of a user implemented ITokenizer< TTokenType >, which must use the
  ///    same data-type for < TTokenType >.
  ///  </summary>
  ILexer< TTokenType > = interface
    ['{25FCCEC4-FC06-4E65-BA33-E882100459CE}']

    ///  <summary>
    ///    Returns the cursor location at which the
    ///    current token was found.
    ///  </summary>
    function Cursor: ICursor;

    ///  <summary>
    ///    If the token contains data, such as a numerical
    ///    or string literal, that data is returned by this method.
    ///  </summary>
    function Data: string;

    ///  <summary>
    ///    This overload of Expect() tests to see if the current token
    ///    matches that in the 'Token' parameter. If the current token
    ///    is not of the specified type, an stExpected status is returned
    ///    which is pre-populated using the 'expected' string parameter.
    ///  </summary>
    function Expect( const Token: TTokenType; const Expected: string ): TStatus; overload;

    ///  <summary>
    ///    This overload of Expect() tests to see if the current token matches
    ///    one of those in the 'Tokens' array parameter. If the current token
    ///    does not match one of those specified, an stExpected status is
    ///    returned, which is pre-populated using the 'expected' string parameter.
    ///  </summary>
    function Expect( const Tokens: array of TTokenType; const Expected: string ): TStatus; overload;

    ///  <summary>
    ///     Returns true if the current token matches the 'Token' parameter.
    ///  </summary>
    function Match( const Token: TTokenType ): boolean; overload;

    ///  <summary>
    ///     Returns true if the current token matches one of those in the 'Tokens' array parameter.
    ///  </summary>
    function Match( const Tokens: array of TTokenType ): boolean; overload;

    ///  <summary>
    ///    The generic TTokenType is expected to be an enum type, and this method
    ///    will return the current token. When instancing TTokenizer< TTokenType >, one
    ///    of the constructor parameters is an 'unknown' token value, which will be the
    ///    default returned token value before a call to 'Next' is made to advance
    ///    the tokenizer through its source stream. <br/>
    ///    The unknown value may also be returned if the user-provided tokenizing
    ///    method is unable to identify the next token. <br/>
    ///    Also watch for a matching 'EOF' token indicating that the tokenizer
    ///    reached the end of its input stream ( again, provided to constructor ).
    ///  </summary>
    function Current: TTokenType;

    ///  <summary>
    ///    Returns true if the tokenizer has reached the end of the input stream.
    ///  </summary>
    function EndOfStream: boolean;

    ///  <summary>
    ///    Advances the tokenizer to the next token in the input stream.
    ///  </summary>
    procedure Next;
  end;

{$endregion}

{$region ' TLexer '}

type
  ///  <summary>
  ///    A factory record for creating instances of ILexer< TTokenType >.
  ///  </summary>
  TLexer< TTokenType > = record
    ///  <summary>
    ///    This factory method takes an instance of ILog,
    ///    a source file path, and a custom tokenizer implementation, to
    ///    instance a lexer which is prepared to tokenize the source file.
    ///  </summary>
    class function Create( const Log: ILog; const SourceFilePath: string; const Tokenizer: ITokenizer< TTokenType > ): ILexer< TTokenType >; overload; static;

    ///  <summary>
    ///    This factory method takes an instance of ILog,
    ///    a source stream, a unicode format, and a custom tokenizer
    ///    implementation, to instance a lexer which is prepared to tokenize
    ///    the source stream.
    ///  </summary>
    class function Create( const Log: ILog; const Source: IUnicodeStream; const UnicodeFormat: TUnicodeFormat; const Tokenizer: ITokenizer< TTokenType > ): ILexer< TTokenType >; overload; static;
  end;

{$endregion}

{$region ' IParser '}

type
  ///  <summary>
  ///    IParser represents your supplied parser for translating source
  ///    code to some model. The utlCompile library will require that a
  ///    factory (TParserFactory see below) be provided in order to register
  ///    your parser with the compile chain. The factory will be provided
  ///    with an instance of the compiler log, and an interface represnting
  ///    the "configuration" for the compiler. This configuration should
  ///    contain the names/directories of any source files required by the
  ///    parser.
  ///  </summary>
  IParser = interface
    ['{C841F2D9-CCCC-4E3D-BD66-D02A51962633}']

    ///  <sumamry>
    ///    Your parser should accept a source code file in its constructor,
    ///    or via configuration. When the Parse() method is called, the parser
    ///    should read the source file and generate the expected output
    ///    model instance.
    ///  </summary>
    function Parse( out ModelInstance: IModelInstance ): TStatus;
  end;

type
  ///  <summary>
  ///    A factory method capable of instancing a parser. <br/>
  ///    Provided to ICompileChains.RegisterChain().
  ///  </summary>
  TParserFactory = function ( const Log: ILog; const Config: IInterface ): IParser;

{$endregion}

{$region ' ITransition '}

type
  ///  <summary>
  ///    Represents a user supplied model transition. <br/>
  ///    Which ever parser or transition which comes before this one in the
  ///    compile chain, will generate the model which this transition takes
  ///    as its 'SourceModel'.  Your transition should generate a new model
  ///    on the out 'TargetModel' parameter. Transitions might be as simple
  ///    as a single optimization of the source, or might transition from
  ///    one model to an entirely different model, it's up to you to provide
  ///    what is needed for your compile chain.
  ///  </summary>
  ITransition = interface
    ['{5DE89ED2-B618-41E4-BFCB-FF5CDD804094}']

    ///  <summary>
    ///    Transition the source model to a target model.
    ///  </summary>
    function Transition( const SourceModel: IModelInstance; out TargetModel: IModelInstance ): TStatus;
  end;

{$endregion}

{$region ' ICodeGenerator '}

type
  ///  <summary>
  ///    A CodeGenerator takes a model (the product of parsing or transitioning)
  ///    as its input, and generates one or more output files. Typically the
  ///    output file will be source-code for some other tool, such as an assembler
  ///    for instance.
  ///  </summary>
  ICodeGenerator = interface
    ['{C7F5ED2C-0A29-49AD-BCE8-7F8F125030C7}']

    ///  <summary>
    ///    Transition the source model to one or more output files. <br/>
    ///    SourceModel - The model to generate code from. <br/>
    ///  </summary>
    function Generate( const SourceModel: IModelInstance ): TStatus;
  end;

{$endregion}

{$region ' IPostProcess '}

type
  ///  <summary>
  ///    A post process is an optional step in the compile chain, after a
  ///    code generator has been called to generate output, the post process
  ///    may be called to operate on that output. For instance, a code
  ///    generator might generate an assembler source file, the post process
  ///    could call on an external assembler to assemble the source,
  ///    and then call an external linker to generate the final executable. <br/>
  ///    The code generator may use the config model instance to forward
  ///    information to the post-process, such as the names of the files
  ///    that it generated to be operated on.
  ///  </summary>
  IPostProcess = interface
    ['{302EC0EA-3D21-451B-9EFA-42F7F4422411}']
    function Run(): TStatus;
  end;

{$endregion}

{$region ' ICompileChain '}

type
  ///  <summary>
  ///    A compile chain represents a collection of various compiler components
  ///    to transition source code to the final output. It will always have
  ///    at least a parser and a code generator. It may also contain one or
  ///    more transitions, and may contain one or more post processes. <br/>
  ///    Compile chains are registered with the 'CompileChains' singleton
  ///    in order that the compiler application be able to determine which
  ///    chains are available, and call upon them as requested by the user.
  ///  </summary>
  ICompileChain = interface
    ['{D2838329-44C2-472E-A9D7-A80D84FEBEE9}']

    ///  <summary>
    ///    All compilers have different configurations, and so an interface
    ///    reference is configured to represent the configuration. Each
    ///    component of the chain may cast this interface to the appropriate
    ///    configuration type.
    ///  </summary>
    function Configuration: IInterface;

    ///  <summary>
    ///    The compile chain will progress the compilation process from the
    ///    initial parsing phase, through any number of transitions, to the
    ///    code generation phase, and then any number of post processes which
    ///    may be required to complete compilation. <br/>
    ///    Immediately after Parse(), if successful, this method will return
    ///    the model in its current state, and will continue to return the
    ///    current state of the model after each successive call to
    ///    Transition(). When all transforms have been applied, a call to
    ///    Generate() is made, at which point this method will return nil. <br/>
    ///    This is because the model will have been disposed, it is no
    ///    longer required after the code generator has used it to generate
    ///    an assembler file. <br/>
    ///    This method exists to aid in debugging the compiler, and has no use
    ///    in a production build.
    ///  </sumamry>
    function Model: IModelInstance;

    ///  <summary>
    ///    Attempts to parse the configured source code file. <br/>
    ///    Note: This is step-1 of the compilation process, and will set the
    ///    internal transition counter to zero, and reinitialize the model
    ///    which is returned by the Model() method above. <br/>
    ///  </summary>
    function Parse: TStatus;

    ///  <summary>
    ///    After parsing, the model may be passed through several transitions
    ///    before being passed to the generate phase. The Transition() method
    ///    must be called repeatedly until it returns either an error status,
    ///    or the stDone status, indicating that there are no further
    ///    transition in the compile chain.
    ///  </summary>
    function Transition: TStatus;

    ///  <summary>
    ///    The Generate stage may be called only when all transitions have
    ///    been made. An error will be returned if transitioning is incomplete
    ///    when Generate is called. <br/>
    ///    The Generate method will use the internal model to generate one or
    ///    more output files which may be the final result of compilation, or
    ///    which may be required as input to post processes (such as assemble
    ///    and link phases). <br/>
    ///  </summary>
    function Generate: TStatus;

    ///  <summary>
    ///    PostProcess should be called after Generate() has completed
    ///    successfully. Attempting to call PostProcess before Generate is
    ///    called will cause an error to be returned. <br/>
    ///    As with Transition(), PostProcess() should be called repeatedly
    ///    until it returns stDone. There may be several post processing
    ///    steps required to transform the output of Generate into the
    ///    final product of compilation.  Examples of post processes are
    ///    to call an assembler, and linker to take the output of Generate
    ///    and produce an executable for the selected target.
    ///  </summary>
    function PostProcess: TStatus;

  end;

{$endregion}

{$region ' Factories for parser, transitions, code generators, and post processes. '}



  ///  <summary>
  ///    A factory method capable of instancing a transition. <br/>
  ///    Provided to ICompileChains.RegisterChain().
  ///  </summary>
  TTransitionFactory = function ( const Log: ILog; const Config: IInterface ): ITransition;

  ///  <summary>
  ///    A composite of a factory for a transition, and it's usage value.
  ///    This record exists as a convenience for registering transitions
  ///    with a compile chain, see ICompileChains.RegisterChain().
  ///  </summary>
  TTransitionRecord = record
    Factory: TTransitionFactory;
    OutputName: string;
  public
    class function Create( const OutputName: string; const Factory: TTransitionFactory ): TTransitionRecord; static;
  end;

  ///  <summary>
  ///    A factory method capable of instancing a code generator. <br/>
  ///    Provided to ICompileChains.RegisterChain().
  ///  </summary>
  TCodeGeneratorFactory = function ( const Log: ILog; const Config: IInterface ): ICodeGenerator;

  ///  <summary>
  ///    A factory method capable of instancing a post process. <br/>
  ///    Provided to ICompileChians.RegisterChain().
  ///  </summary>
  TPostProcessFactory = function ( const Log: ILog; const Config: IInterface ): IPostProcess;

{$endregion}

{$region ' ICompileChains '}

type
  ///  <summary>
  ///    A factory which is able to instance a configuration model for
  ///    a compile chain.
  ///  </summary>
  TConfigFactory = reference to function( const Platform: TPlatform; const Target: TTarget ): IInterface;

type
  ///  <summary>
  ///    A configuration handler is a function/method which takes an existing
  ///    instance of the configuration model, and adjusts the configuration
  ///    upon the creation of a compile chain.
  ///  </summary>
  TConfigurationHandler = reference to procedure( const ConfigModel: IInterface );

type
  ///  <summary>
  ///    A collection representing the installed compile chains that the
  ///    compiler application may select from in order to compile a source
  ///    file. <br/> This interface provides access to the functionality of
  ///    the singleton 'CompileChains'.
  ///  </summary>
  ICompileChains = interface
    ['{484327C6-4E5E-49B3-93EB-4325207440EF}']

    ///  <summary>
    ///    For each chain created, register a factory method which can be
    ///    used to instance the chain.
    ///  </summary>
    function RegisterChain( const SourceSyntax: string;
                            const Platform: TPlatform;
                            const Target: TTarget;
                            const Parser: TParserFactory;
                            const Transitions: array of TTransitionRecord;
                            const CodeGenerator: TCodeGeneratorFactory;
                            const PostProcesses: array of TPostProcessFactory;
                            const ConfigFactory: TConfigFactory
                          ): ICompileChain;

    ///  <summary>
    ///    Selects a compile chain using the SourceSyntax, Target and Platform
    ///    parameters to identify which chain to create. <br/>
    ///    After your compile chain has been instanced and returned, be sure to
    ///    set up its configuration (see ICompileChain.Configuration ), before
    ///    attempting to perform compilation. At minimum you should create the
    ///    configuration root representation, and set some member of it which
    ///    the parser will understand to be the source code file/stream.
    ///  </summary>
    function CreateChain( const Log: ILog;
                          const SourceSyntax: string;
                          const Platform: TPlatform;
                          const Target: TTarget;
                          const ConfigHandler: TConfigurationHandler ): ICompileChain;

    ///  <summary>
    ///    Returns a list of available input syntax based on what has been
    ///    registered.
    ///  </summary>
    function InputSyntax: IReadOnlyList< string >;

    ///  <summary>
    ///    Returns a list of available platforms for a given input
    ///    syntax, based on what has been registered.
    ///  </summary>
    function Platforms( const InputSyntax: string ): IReadOnlyList< TPlatform >;

    ///  <summary>
    ///    Returns a list of target archetectures for a given input
    ///    syntax and platform, based on what has been registered.
    ///  </summary>
    function Targets( const InputSyntax: string; const Platform: TPlatform ): IReadOnlyList< TTarget >;

    ///  <summary>
    ///    Returns a list of names identifying the output after each transition
    ///    for a given input syntax, platform and target. These names are
    ///    arbitrarily defined when registering transitions, and are used
    ///    exclusively for debugging purposes. Do not rely on these to be
    ///    unique, or to follow any identifier rules.
    ///  </summary>
    function ModelNames( const InputSyntax: string; const Platform: TPlatform; const Target: TTarget ): IReadOnlyList< string >;
  end;

{$endregion}

{$region ' ISymbols '}

type
  ///  <summary>
  ///    A base interface for ILabelSymbol and INumericSymbol.
  ///  </summary>
  IScopedSymbol = interface
  ['{9C7AC085-E23A-4701-804A-C26FC1315A2B}']
  end;

  ///  <summary>
  ///    A symbol that reflects a label in the target assembler source file.
  ///  </summary>
  ILabelSymbol = interface( IScopedSymbol )
  ['{C7979AF3-105A-4429-AEA9-65100B3C2CB8}']

    ///  <summary>
    ///    Returns the assembler file source label for this symbol.
    ///  </summary>
    function SourceLabel: string;
  end;

  ///  <summary>
  ///    A symbol that reflects a numeric value, such as an offset from the
  ///    stack frame base.
  ///  </summary>
  INumericSymbol = interface( IScopedSymbol )
  ['{53174387-B00D-4AB1-BDC3-645AF1436FFF}']

    ///  <summary>
    ///     Returns the numeric value for this symbol.
    ///  </summary>
    function Value: uint64;
  end;

type
  ///  <summary>
  ///    As a utility for use in transitions / code generation, the ISymbolTree
  ///    interface represents a scope-enabled tree of symbols which reflect
  ///    identifiers in the source code. This tree allows generation of code
  ///    using globally unique symbols to identify items in the final output,
  ///    which might otherwise have colliding identifiers dependant on scope.
  ///  </summary>
  IScopedSymbols = interface
    ['{4DCF2116-37EB-4397-86B7-27FDD98A30DA}']

    ///  <summary>
    ///    Increments the level of scope such that new symbols may be added.
    ///  </summary>
    procedure IncrementScope;

    ///  <summary>
    ///    Decrements the level of scope. Any symbols created at the current
    ///    scope level before decrement will no longer be accessible via
    ///    local identifier as they have "gone out of scope."
    ///  </summary>
    procedure DecrementScope;

    ///  <summary>
    ///    Adds a label symbol at the current scope level, using the provided
    ///    identifier as its key. Note that the symbol will be automatically
    ///    generated in order to ensure that it is globally unique.
    ///  </summary>
    function AddLabelSymbol( const Identifier: string ): IScopedSymbol;

    ///  <summary>
    ///    Adds a numeric symbol at the current level of scope, using the
    ///    provided identifier as its key.
    ///  </summary>
    function AddNumericSymbol( const Identifier: string; const Value: uint64 ): IScopedSymbol;

    ///  <summary>
    ///    Recursing up the levels of scope, locates a symbol by its identifier. <br/>
    ///    If not nil, the returned symbol must be inspected to determine if it
    ///    is an ILabelSymbol or an INumericSymbol.
    ///  </summary>
    function SymbolLookup( const Identifier: string ): IScopedSymbol;
  end;

type
  TScopedSymbols = record
    class function Create: IScopedSymbols; static;
  end;

{$endregion}

///  <summary>
///    Returns a singleton instance of ICompileChains which represents the
///    collection of available compiler chains.
///  </summary>
function CompileChains: ICompileChains;

///  <summary>
///    Utility to return a TTarget as a string.
///  </summary>
function TargetName( const Target: TTarget ): string;

///  <summary>
///    Utility to return a TTarget given its string representation.
///  </summary>
function TargetFromName( const Name: string ): TTarget;

///  <summary>
///    Utility to return a TPlatform as a string.
///  </summary>
function PlatformName( const Platform: TPlatform ): string;

///  <summary>
///    Utility to return a TPlatform given it's string representation.
///  </summary>
function PlatformFromName( const Name: string ): TPlatform;

///  <summary>
///    Provides access to a global singleton instance of IModels.
///  </summary>
function Models: IModels;

implementation
uses
  System.TypInfo
, SysUtils
, utlTypes
, utlCompile.CompileChains
, utlCompile.Symbols
, utlCompile.Cursor
, utlCompile.Scanner
, utlCompile.Lexer
, utlCompile.ModelStorage
, utlCompile.Models
;

var
  SingletonCompileChains: ICompileChains = nil;
  SingletonModels: IModels = nil;

function Models: IModels;
begin
  if not assigned( SingletonModels ) then begin
    SingletonModels := TModels.Create;
  end;
  Result := SingletonModels;
end;

function TargetName( const Target: TTarget ): string;
begin
  Result := GetEnumName( System.TypeInfo( TTarget ), ord( Target ) ).Replace( 'tgt_', '' );
end;

function PlatformName( const Platform: TPlatform ): string;
begin
  Result := GetEnumName( System.TypeInfo( TPlatform ), ord( Platform ) ).Replace( 'pl_', '' );;
end;

function TargetFromName( const Name: string ): TTarget;
var
  utName: string;
begin
  utName := Name.UppercaseTrim;
  for Result := Low( TTarget ) to High( TTarget ) do begin
    if TargetName( Result ).UppercaseTrim = utName then exit;
  end;
  Result := tgt_Unset;
end;

function PlatformFromName( const Name: string ): TPlatform;
var
  utName: string;
begin
  utName := Name.UppercaseTrim;
  for Result := Low( TPlatform ) to High( TPlatform ) do begin
    if PlatformName( Result ).UppercaseTrim = utName then exit;
  end;
  Result := pl_Unset;
end;



function CompileChains: ICompileChains;
begin
  if not assigned( SingletonCompileChains ) then begin
    SingletonCompileChains := TCompileChains.Create;
  end;
  Result := SingletonCompileChains;
end;

class function TTransitionRecord.Create( const OutputName: string; const Factory: TTransitionFactory ): TTransitionRecord;
begin
  Result.OutputName := OutputName;
  Result.Factory := Factory;
end;

class function TScopedSymbols.Create: IScopedSymbols;
begin
  Result := utlCompile.Symbols.TScopedSymbols.Create;
end;

class function TLexer< TTokenType >.Create( const Log: ILog; const Source: IUnicodeStream; const UnicodeFormat: TUnicodeFormat; const Tokenizer: ITokenizer< TTokenType >): ILexer< TTokenType >;
begin

end;

class function TLexer< TTokenType >.Create( const Log: ILog; const SourceFilePath: string; const Tokenizer: ITokenizer< TTokenType >): ILexer< TTokenType >;
var
  Scanner: IScanner;
  FS: IUnicodeStream;
begin
  FS := TFileStream.Create( SourceFilePath, TRUE );
  try
    Scanner := TScanner.Create( ExtractFileName( SourceFilePath ), FS, TUnicodeFormat.utfUnknown );
  finally
    FS := nil;
  end;
  try
    Result := utlCompile.Lexer.TLexer< TTokenType >.Create( Log, Scanner, Tokenizer );
  finally
    Scanner := nil;
  end;
end;

{ TCursor }

class function TCursor.Create( const Filename: string; const LineNumber, LinePosition: nativeuint ): ICursor;
begin
  Result := utlCompile.Cursor.TCursor.Create( Filename, LineNumber, LinePosition );
end;

initialization
  SingletonModels := nil;
  SingletonCompileChains := nil;
  TStatus.Register( stDone                     , '' );
  TStatus.Register( stSourceNotParsed          , 'Internal Error: Attempt to call transition, generate, or post-process before source has been parsed.' );
  TStatus.Register( stModelNotTransitioned     , 'Internal Error: Attempt to call generate or post-process before completing transitions. ');
  TStatus.Register( stNotGenerated             , 'Internal Error: Attempt to call post-process before code is generated. ');
  TStatus.Register( stChainAlreadyRegistered   , 'Internal Error: A compile-chain for "(%%)" to target "(%%)"."(%%)" is already registered.' );
  TStatus.Register( stSourceModelIsInvalid     , 'Internal Error: The transition or generator source model is not valid.' );
  TStatus.Register( stSourceModelIsMissingRoot , 'Internal Error: The transition or generator source model is missing its root node.' );
  TStatus.Register( stInvalidTarget            , 'Internal Error: Invalid target for operation.' );
  TStatus.Register( stInvalidPlatform          , 'Internal Error: Invalid platform for operation.' );
  TStatus.Register( stExpected                 , '(%%): Expected "(%%)"' );
  TStatus.Register( stModelAlreadyRegistered              , 'Model already registered by name: "(%%)"' );
  TStatus.Register( stArchetypeNotFound                   , 'Archetype could not be found by GUID: "(%%)"' );
  TStatus.Register( stArchetypeAlreadyRegistered          , 'Archetype already registered: "(%%)"' );
  TStatus.Register( stArchetypeFactoryFailed              , 'The factory method failed when attempting to instance archetype "(%%)"' );
  TStatus.Register( stArchetypeImplementationMissing      , 'Archetype implementation missing: "(%%)"' );
  TStatus.Register( stArchetypeMemberClash                , 'Cannot add member "(%%)" to archetype "(%%)" due to member offset clash."' );
  TStatus.Register( stSerializationError                  , 'Stream write error while attempting to serialize model instance.' );
  TStatus.Register( stUnrecognizedDataTypeInStorage       , 'The storage class encountered an unknown data-type in the model instance.' );
  TStatus.Register( stArchetypeMemberDisplayNameMissmatch , 'Stream does not match model: Archetype member display name missmatch.' );
  TStatus.Register( stArchetypeMemberDataTypeMissmatch    , 'Stream does not match model: Archetype member data-type missmatch.' );
  TStatus.Register( stArchetypeMemberOffsetMissmatch      , 'Stream does not match model: Archetype member offset missmatch.' );
  TStatus.Register( stArchetypeIDMissmatch                , 'Stream does not match model: Archetype ID missmatch.' );
  TStatus.Register( stArchetypeMemberCountMissmatch       , 'Stream does not match model: Archetype member count missmatch.' );
  TStatus.Register( stArchetypeCountMissmatch             , 'Stream does not match model: Archetype count missmatch.' );
  TStatus.Register( stSignatureInvalid                    , 'Stream does not match model: Invalid signature.' );
  TStatus.Register( stArchetypeDisplayNameMissmatch       , 'Stream does not match model: Archetype display name missmatch.' );
  TStatus.Register( stStorageInvalidBooleanData           , 'Stream contains invalid data for boolean member.' );
  TStatus.Register( stInvalidStringIndex                  , 'Stream contains invalid data for string member.'  );
  TStatus.Register( stUnidentifiedReference               , 'Encountered reference which is not a valid representation.' );
  TStatus.Register( stUnidentifiedListItemReference       , 'Encountered reference within list which is not a valid representation.' );
  TStatus.Register( stUnidentifiedReferenceMemberType     , 'Cannot resolve reference as type is unknown. ' );
  TStatus.Register( stInvalidResolveIndex                 , 'Cannot resolve reference as index is invalid. ' );
  TStatus.Register( stMalformedResolveTable               , 'Cannot resolve reference as resolver table is invalid. ');
  TStatus.Register( stIdentAddressUnresoved               , 'Unable to resolve ident address for representation. ' );
  TStatus.Register( stCursorFoundButNotSupported          , 'Cursor information was found in the stream during deserialization, but representation does not support a cursor. Corrupt stream?' );
  TStatus.Register( stModelInstanceNotAssigned            , 'Model instance not assigned.' );
  TStatus.Register( stRepesentationInstanceNotAssigned    , 'Representation instance not assigned.' );
  TStatus.Register( stRepresentationNotFound              , 'Representation not found.' );

finalization
  SingletonCompileChains := nil;
  SingletonModels := nil;

end.
